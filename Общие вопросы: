1.Что такое ООП?

Объектно-ориентированное программирование (ООП) — это парадигма программирования, основанная на концепции объектов, которые содержат данные и методы для их обработки. Основные принципы ООП:

Инкапсуляция — скрытие внутренней реализации объекта и предоставление интерфейса для взаимодействия с ним.
Наследование — возможность создавать новые классы, используя свойства и методы существующих.
Полиморфизм — возможность одного интерфейса работать с объектами разных типов.
Абстракция — выделение важной информации и игнорирование деталей, не относящихся к текущей задаче.
ООП помогает делать программы более организованными, удобными для сопровождения и расширения, а также улучшает повторное использование кода.

2.Магическое число 7 Миллера

Магическое число 7 Миллера (психологическое исследование) утверждает, что человек может одновременно держать в своей памяти не более 7 объектов. В контексте IT это число встречается в различных аспектах разработки, например:

Максимальная длина телефонного номера — обычно ограничивается 7 цифрами, что помогает пользователю легко запомнить номер.
Количество элементов в меню — эффективные меню часто содержат 7-9 опций.
Количество объектов в UI (пользовательском интерфейсе) — оптимальное количество элементов для восприятия пользователем.
Размер блока данных в сети (MTU) — часто ограничение на размер пакета данных в сетях близко к 7.
Количество параметров функции — для удобства восприятия рекомендуется иметь до 7 параметров.
Число вкладок в браузере — оптимальное количество открытых вкладок для пользователя составляет около 7.
Количество строк в коде функции — считается, что функция должна содержать не более 7 строк, чтобы быть легко читаемой и поддерживаемой.
Энтропия ПО

3.Энтропия программного обеспечения — это мера сложности или хаоса в программе, которая затрудняет её понимание и поддержку. Примеры негэнтропийных мер при разработке ПО:

Модульность — разделение системы на независимые модули, каждый из которых решает одну задачу.
Документирование кода — наличие документации, которая помогает разработчикам понять, как работает код.
Чистота кода — соблюдение принципов написания читаемого, логичного кода.
Использование паттернов проектирования — применение проверенных решений для распространённых задач.
Тестирование — наличие юнит-тестов и интеграционных тестов, что повышает доверие к качеству ПО и упрощает внесение изменений.
5 признаков сложной системы по Гради Бучу

4.Гради Буч выделил пять признаков сложных систем:

Несколько взаимосвязанных компонентов — система состоит из множества взаимосвязанных частей.
Пример из лабораторной работы: В проекте по созданию микросервиса для интернет-магазина, различные компоненты (например, каталог товаров, управление корзиной, обработка заказов) взаимодействуют друг с другом через API.
Пример из pet проекта: В разработке социальной сети для общения, отдельные компоненты, такие как база данных пользователей, система уведомлений и чат, работают совместно для обеспечения функционирования сервиса.
Невозможность предсказать поведение системы при изменении одного из её компонентов — малое изменение может вызвать каскад изменений.
Пример из лабораторной работы: В проекте по созданию приложения для управления задачами, изменение одной части кода может вызвать ошибку в другом модуле, например, при изменении модели данных для задач.
Пример из pet проекта: В реализации функции поиска в интернет-магазине изменение алгоритма сортировки товаров может неожиданно повлиять на скорость работы системы, особенно при большой нагрузке.
Отсутствие универсальных решений — нет единого подхода, который бы подходил для всех частей системы.
Пример из лабораторной работы: В приложении для работы с данными, использование одной технологии для обработки всех типов данных может привести к неэффективности. Для разных типов данных нужны разные алгоритмы обработки.
Пример из pet проекта: В проекте по созданию многопользовательской игры, для каждой функции (система чатов, физика объектов, обработка движений игроков) требуются уникальные подходы и решения.
Наличие множества ограничений — существует несколько факторов, которые ограничивают возможные решения.
Пример из лабораторной работы: В проекте по разработке алгоритма для оптимизации маршрутов, необходимо учитывать множество ограничений, таких как время работы сервисов, ограничения по скорости и доступности путей.
Пример из pet проекта: В проекте по созданию системы рекомендаций для видео, нужно учитывать предпочтения пользователей, доступность контента, а также ограничения по мощности серверов.
Неопределённость и отсутствие полной информации о системе — часто приходится работать с неполными или частичными данными.
Пример из лабораторной работы: В проекте по анализу больших данных для предсказания потребностей клиентов, многие данные могут быть неполными или неактуальными, что усложняет задачу.
Пример из pet проекта: В разработке системы для управления проектами, часто информация о задачах может быть неполной (например, пользователи не всегда точно заполняют все поля), что приводит к неопределенности в функционировании системы.
Закон иерархических компенсаций Седова

5.Закон Седова утверждает, что в процессе эволюции сложных систем (в том числе в IT) иерархии, составляющие систему, компенсируют друг друга для достижения более высокой стабильности и эффективности. Примеры применения закона Седова в эволюции IT:

Развитие операционных систем: В первых версиях операционных систем использовались простые, монолитные архитектуры. С развитием технологий (например, микросервисы) возникла иерархия различных сервисов и компонентов, компенсирующих друг друга, чтобы достичь более гибкой и масштабируемой системы.
Архитектура облачных вычислений: Ранее существовали монолитные серверные решения, которые с развитием облачных платформ стали заменяться микросервисными архитектурами, где различные компоненты взаимно компенсируют друг друга, повышая устойчивость.
Развитие баз данных: В старых реляционных базах данных вся логика обработки данных была в одной системе. Сегодня с развитием NoSQL баз данных и распределённых хранилищ системы базы данных могут быть гибко распределены, что компенсирует нагрузки.
Развитие языков программирования: В прошлом языки программирования были однотипными, но с развитием появились различные парадигмы (функциональные, объектно-ориентированные и т.д.), компенсирующие ограничения каждого подхода.
Управление проектами: В более ранних версиях проектного менеджмента были жёсткие иерархии и процессы. Современные методы, такие как Agile, компенсируют это, создавая более гибкие и самоорганизующиеся команды.
